<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat con Gemini 2.0 Flash</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        /* --- Basic Reset --- */
 * { margin: 0; padding: 0; box-sizing: border-box; }

/* --- Body Styling & Theme Variables --- */
body {
    font-family: 'Inter', sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: var(--bg-color, #f0f2f5); /* Default light */
    color: var(--text-color, #333);
    transition: background-color 0.3s, color 0.3s;
    padding: 1rem; /* Padding for smaller screens */
}

/* Light Theme (Default) */
body[data-theme="light"] {
    --bg-color: #f0f2f5;
    --text-color: #333;
    --header-bg: #ffffff;
    --chat-bg: #ffffff;
    --input-bg: #ffffff;
    --user-msg-bg: #dcf8c6;
    --bot-msg-bg: #e9e9eb;
    --button-bg: #007bff;
    --button-text: #ffffff;
    --button-hover-bg: #0056b3;
    --icon-color: #555;
    --border-color: #ddd;
    --indicator-color: #ccc;
    --config-bg: #ffffff;
    --config-border: #e0e0e0;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --stop-listen-bg: #6c757d;
    --stop-listen-hover-bg: #5a6268;
    --scrollbar-thumb: #007bff;
    --scrollbar-track: #ffffff;
}

/* Dark Theme */
body[data-theme="dark"] {
    --bg-color: #121212;
    --text-color: #e0e0e0;
    --header-bg: #1e1e1e;
    --chat-bg: #1e1e1e;
    --input-bg: #2c2c2c;
    --user-msg-bg: #056162; /* Darker green for user messages */
    --bot-msg-bg: #3a3a3a;
    --button-bg: #0d6efd; /* Slightly brighter blue */
    --button-text: #ffffff;
    --button-hover-bg: #0b5ed7;
    --icon-color: #bbb;
    --border-color: #444;
    --indicator-color: #555;
    --config-bg: #2c2c2c;
    --config-border: #444;
    --shadow-color: rgba(255, 255, 255, 0.1);
    --stop-listen-bg: #6c757d;
    --stop-listen-hover-bg: #5a6268;
    --scrollbar-thumb: #0d6efd;
    --scrollbar-track: #1e1e1e;
}

/* --- App Structure --- */
.app-container {
    background-color: var(--header-bg);
    border-radius: 12px;
    box-shadow: 0 4px 15px var(--shadow-color);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: 700px;
    height: 90vh;
    max-height: 800px;
    position: relative; /* For config menu positioning */
}

header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--header-bg);
    flex-shrink: 0; /* Prevent header from shrinking */
}

header h1 {
    font-size: 1.25rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--text-color);
}

header h1 i {
    color: var(--button-bg);
}

.header-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

/* --- Context Indicator --- */
.context-indicator {
    font-size: 0.8rem;
    padding: 0.3rem 0.6rem;
    border-radius: 15px; /* Pill shape */
    background-color: var(--indicator-color);
    color: var(--bg-color); /* Contrast text */
    transition: background-color 0.3s;
    cursor: default;
    white-space: nowrap; /* Prevent wrapping */
}
.context-indicator.empty { background-color: #dc3545; color: white;} /* Red for empty */
.context-indicator.medium { background-color: #ffc107; color: #333;} /* Yellow for medium */
.context-indicator.full { background-color: #28a745; color: white;} /* Green for full */

/* --- Main Chat Area --- */
main {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    padding: 0 1.5rem 1rem;
    overflow: hidden; /* Prevent content overflow */
}

#chat-container {
    flex-grow: 1;
    overflow-y: auto; /* Enable scrolling */
    padding: 1rem 0;
    margin-bottom: 1rem; /* Space before input */
    display: flex;
    flex-direction: column;
    scrollbar-width: thin; /* Firefox */
    scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); /* Firefox */
}

/* Webkit Scrollbar Styles */
#chat-container::-webkit-scrollbar { width: 8px; }
#chat-container::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 4px; }
#chat-container::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 4px; border: 2px solid var(--scrollbar-track); }

#chat {
    display: flex;
    flex-direction: column;
    gap: 0.75rem; /* Space between messages */
}

.message {
    padding: 0.75rem 1rem;
    border-radius: 12px;
    max-width: 80%;
    word-wrap: break-word;
    line-height: 1.4;
    position: relative; /* For speak button */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Subtle shadow */
}

.user-message {
    background-color: var(--user-msg-bg);
    /* Ensure text color contrasts with background */
    color: var(--theme, light) == 'light' ? #333 : #e0e0e0;
    align-self: flex-end;
    border-bottom-right-radius: 4px; /* Tail effect */
}

.bot-message {
    background-color: var(--bot-msg-bg);
    color: var(--text-color);
    align-self: flex-start;
    border-bottom-left-radius: 4px; /* Tail effect */
    padding-bottom: 2.2rem; /* Space for the speak button */
}

/* Speak button for bot messages */
.speak-button {
    position: absolute;
    bottom: 6px; /* Adjusted position */
    right: 10px;
    background: none;
    border: none;
    color: var(--button-bg);
    font-size: 1rem;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s, color 0.2s;
    padding: 2px; /* Add some clickable area */
}
.speak-button:hover { opacity: 1; }
.speak-button.speaking { color: #dc3545; } /* Indicate speaking */

/* --- Transcription Info (Hidden by default via JS now) --- */
#transcription-info {
    position: absolute; /* Position relative to app-container */
    bottom: 85px; /* Position above input area */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-size: 0.85rem;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.3s;
    pointer-events: none; /* Don't block clicks */
    z-index: 5;
    max-width: 90%;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: none; /* Initially hidden completely */
}
#transcription-info.active {
    opacity: 1; /* Make visible when active */
    display: block; /* Show the element */
}

.system-message {
    font-style: italic;
    color: var(--icon-color);
    align-self: center;
    font-size: 0.85rem;
    background-color: transparent;
    text-align: center;
    margin: 0.5rem 0;
    padding: 0.2rem 0.5rem;
}

/* --- Typing Indicator --- */
#typing-indicator {
    display: flex;
    align-items: center;
    padding: 0.5rem 1rem;
    margin-top: 0.5rem;
    align-self: flex-start; /* Align with bot messages */
}
#typing-indicator.hidden { display: none; }
.dot {
    width: 8px; height: 8px; margin: 0 3px;
    background-color: var(--icon-color);
    border-radius: 50%;
    animation: typing 1.4s infinite ease-in-out both;
}
.dot:nth-child(1) { animation-delay: -0.32s; }
.dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes typing {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1.0); }
}

/* --- Input Area --- */
.input-area-container {
    padding: 0 1.5rem 1rem; /* Match main padding */
    flex-shrink: 0; /* Prevent shrinking */
}
.input-area {
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem;
    border: 1px solid var(--border-color);
    border-radius: 25px; /* Pill shape */
    background-color: var(--input-bg);
    align-items: center; /* Align items vertically */
}

#input {
    flex-grow: 1;
    border: none;
    outline: none;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    background-color: transparent;
    color: var(--text-color);
    line-height: 1.4; /* Ensure text doesn't jump */
}
#input::placeholder { color: var(--icon-color); opacity: 0.8; }

.icon-button {
    background: none; border: none;
    color: var(--button-bg);
    font-size: 1.25rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    transition: background-color 0.2s, color 0.2s;
    flex-shrink: 0; /* Prevent button shrinking */
}
.icon-button:hover { background-color: rgba(0, 123, 255, 0.1); }
.icon-button:disabled { color: var(--indicator-color); cursor: not-allowed; background-color: transparent; }
.icon-button i { display: block; }

/* --- Control Buttons --- */
.controls {
    display: flex;
    justify-content: center;
    gap: 0.75rem;
    margin-top: 1rem;
    padding: 0 1.5rem; /* Match main padding */
    flex-wrap: wrap; /* Allow buttons to wrap */
    flex-shrink: 0; /* Prevent shrinking */
}

.control-button {
    background-color: var(--button-bg);
    color: var(--button-text);
    border: none;
    padding: 0.75rem 1.25rem;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 500;
    display: flex; align-items: center; gap: 0.5rem;
    transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}
.control-button:hover:not(:disabled) {
    background-color: var(--button-hover-bg);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}
.control-button:disabled {
    background-color: var(--indicator-color);
    color: var(--bg-color);
    opacity: 0.7;
    cursor: not-allowed;
    box-shadow: none;
}
.control-button i { font-size: 1rem; }

/* Style for the explicit stop listening button */
#explicitStopBtn { background-color: var(--stop-listen-bg); }
#explicitStopBtn:hover:not(:disabled) { background-color: var(--stop-listen-hover-bg); }

/* --- Config Menu --- */
#configMenu {
    position: absolute; top: 0; right: 0;
    width: 300px; height: 100%;
    background-color: var(--config-bg);
    border-left: 1px solid var(--config-border);
    box-shadow: -5px 0 15px var(--shadow-color);
    transform: translateX(100%);
    transition: transform 0.3s ease-in-out, visibility 0.3s;
    z-index: 10;
    display: flex; flex-direction: column;
    padding: 1.5rem;
    overflow-y: auto; /* Scroll if content overflows */
    visibility: hidden; /* Start hidden */
}
#configMenu:not(.hidden) {
    transform: translateX(0);
    visibility: visible; /* Make visible */
}

.config-header {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 1.5rem; padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}
.config-header h3 { font-size: 1.1rem; font-weight: 600; color: var(--text-color); }
.config-header .icon-button { color: var(--icon-color); }

.config-section { margin-bottom: 1.5rem; }
.config-section h4 {
    font-size: 0.9rem; font-weight: 600; color: var(--text-color);
    margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;
}
.config-section label {
    display: block; margin-bottom: 0.5rem;
    font-size: 0.9rem; color: var(--text-color);
}
.config-section select,
.config-section input[type="range"] {
    width: 100%; padding: 0.5rem; border-radius: 6px;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg);
    color: var(--text-color); font-size: 0.9rem;
}
.config-section input[type="range"] { cursor: pointer; padding: 0; }

.slider-container { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.25rem; }
.slider-container i { color: var(--icon-color); }
.config-section span[id$="Value"] { /* Select rateValue and pitchValue */
    display: block; text-align: center; font-size: 0.85rem;
    color: var(--icon-color); margin-top: 0.25rem;
}

.full-width-btn {
    width: 100%; background-color: #dc3545; color: white;
    border: none; padding: 0.75rem 1rem; border-radius: 6px;
    cursor: pointer; font-size: 0.9rem; font-weight: 500;
    display: flex; align-items: center; justify-content: center; gap: 0.5rem;
    transition: background-color 0.2s;
}
.full-width-btn:hover { background-color: #c82333; }
.full-width-btn i { font-size: 1rem; }
.help-text { font-size: 0.8rem; color: var(--icon-color); margin-top: 0.5rem; text-align: center; }

/* Theme Toggle Switch */
.theme-toggle { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; font-size: 0.9rem; }
.switch { position: relative; display: inline-block; width: 50px; height: 28px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
.slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: var(--button-bg); }
input:focus + .slider { box-shadow: 0 0 1px var(--button-bg); }
input:checked + .slider:before { transform: translateX(22px); }

/* --- Responsive Adjustments --- */
@media (max-width: 600px) {
    body { padding: 0; } /* Remove body padding on mobile */
    .app-container { height: 100vh; max-height: none; border-radius: 0; box-shadow: none; }
    header { padding: 0.75rem 1rem; }
    header h1 { font-size: 1.1rem; }
    main { padding: 0 1rem 0.75rem; }
    .input-area-container { padding: 0 1rem 0.75rem; }
    .controls { padding: 0 1rem; gap: 0.5rem; }
    .control-button { padding: 0.6rem 1rem; font-size: 0.85rem; }
    #configMenu { width: 85%; }
    .message { max-width: 90%; }
    #transcription-info { bottom: 130px; /* Adjust position based on controls */ }
}
@media (max-width: 400px) {
     .control-button { padding: 0.5rem 0.8rem; font-size: 0.8rem; }
     .control-button i { font-size: 0.9rem;}
     header h1 { font-size: 1rem; gap: 0.3rem;}
     .header-controls { gap: 0.5rem;}
     .context-indicator { padding: 0.2rem 0.5rem; font-size: 0.75rem;}
}


    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1><i class="fas fa-robot"></i> Chat con Gemini Flash</h1>
            <div class="header-controls">
                <div id="contextIndicator" class="context-indicator empty" title="Cantidad de mensajes en memoria">
                    Contexto: 0
                </div>
                <button id="toggleConfig" class="icon-button" title="Configuración">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
        </header>

        <main>
            <div id="chat-container">
                <div id="chat">
                    </div>
                <div id="typing-indicator" class="hidden">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>

            <div id="transcription-info" style="display: none;"></div>

        </main>

        <div class="input-area-container">
             <div class="input-area">
                <input type="text" id="input" placeholder="Escribe o habla..." />
                <button id="sendBtn" class="icon-button" title="Enviar mensaje">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
         </div>

         <div class="controls">
             <button id="startBtn" class="control-button">
                 <i class="fas fa-microphone"></i> Hablar
             </button>
             <button id="explicitStopBtn" class="control-button" disabled>
                 <i class="fas fa-microphone-slash"></i> Detener Mic.
             </button>
             <button id="pauseBtn" class="control-button" disabled>
                 <i class="fas fa-pause"></i> Pausar Voz
             </button>
             <button id="resumeBtn" class="control-button" disabled>
                 <i class="fas fa-play"></i> Reanudar Voz
             </button>
             <button id="stopBtn" class="control-button" disabled>
                 <i class="fas fa-stop"></i> Detener Voz
             </button>
         </div>


        <aside id="configMenu" class="hidden">
            <div class="config-header">
                <h3>Configuración</h3>
                <button id="closeConfig" class="icon-button" title="Cerrar configuración">
                    <i class="fas fa-times"></i>
                </button>
            </div>

            <div class="config-section">
                <h4>Voz (TTS)</h4>
                <label for="voiceSelect">Voz preferida:</label>
                <select id="voiceSelect"></select>
            </div>

            <div class="config-section">
                <h4>Velocidad Lectura</h4>
                <div class="slider-container">
                    <i class="fas fa-walking"></i>
                    <input type="range" id="rateSelect" min="0.5" max="2" step="0.1" value="1">
                    <i class="fas fa-running"></i>
                </div>
                <span id="rateValue">1.0</span>
            </div>

            <div class="config-section">
                <h4>Tono Lectura</h4>
                <div class="slider-container">
                    <i class="fas fa-arrow-down"></i>
                    <input type="range" id="pitchSelect" min="0" max="2" step="0.1" value="1">
                    <i class="fas fa-arrow-up"></i>
                </div>
                <span id="pitchValue">1.0</span>
            </div>

            <div class="config-section">
                <h4>Contexto (Memoria)</h4>
                <button id="clearContextBtn" class="full-width-btn">
                    <i class="fas fa-trash"></i> Borrar contexto
                </button>
                <p class="help-text">Elimina la memoria de la conversación actual.</p>
            </div>

            <div class="config-section">
                <h4>Tema Visual</h4>
                <div class="theme-toggle">
                    <span>Claro</span>
                    <label class="switch">
                        <input type="checkbox" id="themeToggle">
                        <span class="slider round"></span>
                    </label>
                    <span>Oscuro</span>
                </div>
            </div>
        </aside>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

    <script>
    // --- Constants & Configuration ---
    // ⚠️ IMPORTANTE: Reemplaza con tu clave API real.
    // Considera usar un proxy backend para proteger tu clave en una aplicación real.
    const API_KEY = "AIzaSyBk2gDvRT_WERHwZW-vuoI_NNnWrOEZ7b8"; // <--- ¡REEMPLAZA ESTO!
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`;
    const MAX_CONTEXT_MESSAGES = 8;
    const RECOGNITION_LANG = 'es-ES';
    const TTS_PREFERRED_LANG = 'es';
    const INTERIM_UPDATE_THRESHOLD = 300; // ms

    // Claves para Local Storage
    const STORAGE_KEYS = {
        THEME: 'geminiChatAppTheme',
        VOICE_NAME: 'geminiChatAppVoiceName',
        VOICE_LANG: 'geminiChatAppVoiceLang',
        RATE: 'geminiChatAppRate',
        PITCH: 'geminiChatAppPitch'
    };

    // --- Global State Variables ---
    let currentSpeech = null;
    let recognition = null;
    let isRecordingIntent = false;
    let isApiRecognizing = false;
    let isSpeaking = false;
    let voices = [];
    let isWaitingForApiResponse = false;
    let wasRecordingBeforeTTS = false;
    let autoScrollEnabled = true;
    let lastInterimUpdateTime = 0;
    let isListeningPaused = false;
    let accumulatedFinalTranscript = '';
    let conversationHistory = []; // El historial NO se guarda en localStorage
    let currentTheme = 'light'; // Se actualizará desde localStorage
    let activeSpeakButton = null;

    // --- DOM Elements ---
    const chatElement = document.getElementById('chat');
    const chatContainer = document.getElementById('chat-container');
    const inputField = document.getElementById('input');
    const startBtn = document.getElementById('startBtn');
    const explicitStopBtn = document.getElementById('explicitStopBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const stopBtn = document.getElementById('stopBtn');
    const sendBtn = document.getElementById('sendBtn');
    const voiceSelect = document.getElementById('voiceSelect');
    const rateSelect = document.getElementById('rateSelect');
    const pitchSelect = document.getElementById('pitchSelect');
    const rateValue = document.getElementById('rateValue');
    const pitchValue = document.getElementById('pitchValue');
    const toggleConfigBtn = document.getElementById('toggleConfig');
    const configMenu = document.getElementById('configMenu');
    const closeConfigBtn = document.getElementById('closeConfig');
    const themeToggle = document.getElementById('themeToggle');
    const typingIndicator = document.getElementById('typing-indicator');
    const clearContextBtn = document.getElementById('clearContextBtn');
    const contextIndicator = document.getElementById('contextIndicator');
    // transcriptionInfo no se usa visualmente

    // --- Sound Effects ---
    const sounds = {
        start: new Howl({ src: ['https://cdn.pixabay.com/audio/2022/03/15/audio_bd4d5c269e.mp3'], volume: 0.3 }),
        stop: new Howl({ src: ['https://cdn.pixabay.com/audio/2021/08/04/audio_a884f8f67c.mp3'], volume: 0.3 }),
        send: new Howl({ src: ['https://cdn.pixabay.com/audio/2022/03/10/audio_1731f14137.mp3'], volume: 0.4 }),
        receive: new Howl({ src: ['https://cdn.pixabay.com/audio/2022/11/10/audio_1e0a9cec63.mp3'], volume: 0.4 })
    };

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadSettings(); // Cargar configuraciones PRIMERO (especialmente el tema)
        setupSpeechRecognition();
        setupSpeechSynthesis(); // Esto llamará a populateVoiceList que aplicará la voz guardada
        addEventListeners();
        addInitialMessage(); // Añadir mensaje inicial después de cargar configuraciones
        updateButtonStates();
        updateContextIndicator();
    });

    // --- Settings Load/Save ---
    function loadSettings() {
        // 1. Cargar Tema
        const savedTheme = localStorage.getItem(STORAGE_KEYS.THEME) || 'light'; // Default a light
        applyTheme(savedTheme);
        themeToggle.checked = savedTheme === 'dark';

        // 2. Cargar Velocidad y Tono (Defaults si no existen)
        const savedRate = localStorage.getItem(STORAGE_KEYS.RATE);
        if (savedRate !== null) {
            rateSelect.value = savedRate;
            rateValue.textContent = parseFloat(savedRate).toFixed(1);
        } else {
             rateValue.textContent = parseFloat(rateSelect.value).toFixed(1); // Mostrar default
        }

        const savedPitch = localStorage.getItem(STORAGE_KEYS.PITCH);
        if (savedPitch !== null) {
            pitchSelect.value = savedPitch;
            pitchValue.textContent = parseFloat(savedPitch).toFixed(1);
        } else {
             pitchValue.textContent = parseFloat(pitchSelect.value).toFixed(1); // Mostrar default
        }

        // La voz se carga dentro de populateVoiceList después de que las voces estén disponibles
        console.log("Settings loaded (Theme, Rate, Pitch). Voice will be applied after voices load.");
    }

    function saveSetting(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            console.error("Error saving setting to localStorage:", e);
            // Podrías mostrar un mensaje al usuario si el almacenamiento falla
            showSystemMessage("No se pudo guardar la configuración (almacenamiento lleno o deshabilitado).", "error");
        }
    }

    // --- Speech Recognition Setup ---
    function setupSpeechRecognition() {
        const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognitionAPI) {
            console.error("Speech Recognition API no soportada.");
            showSystemMessage("El reconocimiento de voz no está disponible en este navegador.", "error");
            startBtn.disabled = true;
            explicitStopBtn.disabled = true;
            return;
        }
        recognition = new SpeechRecognitionAPI();
        recognition.lang = RECOGNITION_LANG;
        recognition.interimResults = true;
        recognition.continuous = true;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => { isApiRecognizing = true; console.log("SR: Started"); updateButtonStates(); };
        recognition.onend = handleRecognitionEnd;
        recognition.onerror = handleRecognitionError;
        recognition.onresult = handleRecognitionResult;
    }

    function handleRecognitionResult(event) {
        if (isSpeaking || isWaitingForApiResponse) { console.log("SR: Ignoring result (TTS/Wait)"); return; }

        let interimTranscript = '';
        const sendCommandRegex = /(.*?)\b(okay|okey|listo)[.?!]?\s*$/i;
        const pauseCommandRegex = /(.*?)\b(espera)\b(.*)/i;
        const resumeCommandRegex = /\b(continuemos|continua)\b/i;

        for (let i = event.resultIndex; i < event.results.length; ++i) {
            const transcriptPart = event.results[i][0].transcript;

            if (event.results[i].isFinal) {
                console.log("SR: Final segment:", transcriptPart);
                if (isListeningPaused) {
                    if (resumeCommandRegex.test(transcriptPart)) {
                        isListeningPaused = false;
                        inputField.value = accumulatedFinalTranscript;
                        console.log("SR: Resume command detected.");
                        updateButtonStates();
                    } else { console.log("SR: Ignoring speech while paused:", transcriptPart); }
                } else {
                    const sendMatch = transcriptPart.match(sendCommandRegex);
                    if (sendMatch) {
                        const textBeforeCommand = sendMatch[1].trim();
                        const commandWord = sendMatch[2];
                        accumulatedFinalTranscript += textBeforeCommand;
                        const finalMessageToSend = accumulatedFinalTranscript.trim();
                        console.log(`SR: Command "${commandWord}". Sending: "${finalMessageToSend}"`);
                        if (finalMessageToSend) { sendMessage(finalMessageToSend); }
                        accumulatedFinalTranscript = ''; inputField.value = ''; isListeningPaused = false;
                        stopRecognition(); return;
                    }
                    const pauseMatch = transcriptPart.match(pauseCommandRegex);
                    if (pauseMatch) {
                        accumulatedFinalTranscript += pauseMatch[1].trim();
                        inputField.value = accumulatedFinalTranscript + " [en espera...]";
                        isListeningPaused = true;
                        console.log(`SR: Pause command "espera". Pausing. Current: "${accumulatedFinalTranscript}"`);
                        updateButtonStates();
                    } else {
                        accumulatedFinalTranscript += transcriptPart;
                        console.log("SR: Appending final segment. Current:", accumulatedFinalTranscript);
                    }
                }
            } else { if (!isListeningPaused) { interimTranscript += transcriptPart; } }
        }
        if (!isListeningPaused) { inputField.value = accumulatedFinalTranscript + interimTranscript; ensureInputFieldVisible(); }
    }

    function handleRecognitionEnd() {
        isApiRecognizing = false;
        console.log("SR: Ended. State - Intent:", isRecordingIntent, "Speaking:", isSpeaking, "Waiting:", isWaitingForApiResponse, "Paused:", isListeningPaused);
        if (isRecordingIntent && !isSpeaking && !isWaitingForApiResponse && !isListeningPaused) {
            console.log("SR: Attempting automatic restart...");
            setTimeout(() => {
                if (isRecordingIntent && !isApiRecognizing && !isSpeaking && !isWaitingForApiResponse && !isListeningPaused) {
                    try { recognition.start(); console.log("SR: Restart successful."); }
                    catch (error) { handleRecognitionError({ error: error.name || 'restart-error', message: error.message }); }
                } else { console.log("SR: Restart aborted due to state change."); updateButtonStates(); }
            }, 250);
        } else { updateButtonStates(); }
    }

    function handleRecognitionError(event) {
        isApiRecognizing = false;
        const error = event.error || 'unknown';
        console.error("SR Error:", error, event.message);
        let errorMessage = "Error en el reconocimiento de voz.";
        if (error === 'no-speech') { errorMessage = "No se detectó habla."; }
        else if (error === 'audio-capture') { errorMessage = "Error capturando audio."; isRecordingIntent = false; }
        else if (error === 'not-allowed') { errorMessage = "Permiso de micrófono denegado."; isRecordingIntent = false; }
        else if (error === 'network') { errorMessage = "Error de red."; }
        else { errorMessage = `Error: ${error}`; if (error !== 'aborted') isRecordingIntent = false; } // No detener intento si fue abortado manualmente
        // Evitar mostrar error si fue un aborto manual o programado
        if (error !== 'aborted' && !(error === 'no-speech' && isRecordingIntent)) {
             showSystemMessage(errorMessage, "error");
        }
        updateButtonStates();
    }

    // --- Speech Synthesis (TTS) Setup ---
    function setupSpeechSynthesis() {
        if (!('speechSynthesis' in window)) {
            console.error("TTS API no soportada.");
            showSystemMessage("La lectura de voz no está disponible.", "error");
            // Deshabilitar controles TTS
            [pauseBtn, resumeBtn, stopBtn, voiceSelect, rateSelect, pitchSelect].forEach(el => {
                if (el) {
                    el.disabled = true;
                    const parentSection = el.closest('.config-section');
                    if (parentSection) parentSection.style.display = 'none';
                }
            });
            return;
        }
        window.addEventListener('beforeunload', () => { if (speechSynthesis.speaking) speechSynthesis.cancel(); });
        // Llenar la lista de voces (puede ser asíncrono)
        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }
    }

    function populateVoiceList() {
        voices = speechSynthesis.getVoices();
        if (voices.length === 0 && !populateVoiceList.retried) {
            console.warn("No TTS voices available immediately. Retrying in 500ms...");
            populateVoiceList.retried = true; // Evitar bucles infinitos
            setTimeout(populateVoiceList, 500);
            return;
        }
        populateVoiceList.retried = false; // Resetear reintento si funciona

        voiceSelect.innerHTML = ''; // Limpiar opciones previas
        const savedVoiceName = localStorage.getItem(STORAGE_KEYS.VOICE_NAME);
        const savedVoiceLang = localStorage.getItem(STORAGE_KEYS.VOICE_LANG);
        let voiceFoundInStorage = false;

        const spanishVoices = voices.filter(voice => voice.lang.startsWith(TTS_PREFERRED_LANG));
        const otherVoices = voices.filter(voice => !voice.lang.startsWith(TTS_PREFERRED_LANG));
        const allVoicesSorted = [...spanishVoices, ...otherVoices];

        allVoicesSorted.forEach(voice => {
            const option = document.createElement('option');
            option.textContent = `${voice.name} (${voice.lang})`;
            option.setAttribute('data-lang', voice.lang);
            option.setAttribute('data-name', voice.name);
            voiceSelect.appendChild(option);

            // Intentar seleccionar la voz guardada
            if (savedVoiceName === voice.name && savedVoiceLang === voice.lang) {
                option.selected = true;
                voiceFoundInStorage = true;
                console.log("Applied saved voice:", voice.name);
            }
        });

        // Si no se encontró la voz guardada, intentar seleccionar una española por defecto
        if (!voiceFoundInStorage && spanishVoices.length > 0) {
            const firstSpanishOption = voiceSelect.querySelector(`option[data-lang^="${TTS_PREFERRED_LANG}"]`);
            if (firstSpanishOption) firstSpanishOption.selected = true;
        }
        // Si no hay ni guardada ni española, seleccionar la primera disponible
        else if (!voiceFoundInStorage && voiceSelect.options.length > 0) {
            voiceSelect.options[0].selected = true;
        }

        console.log("TTS Voices loaded:", voices.length);
        if(voices.length === 0) console.warn("Still no TTS voices available.");
    }

    // --- Core Functions ---
    function startRecognition() {
        if (!recognition) { console.error("SR not initialized."); return; }
        if (isApiRecognizing || isSpeaking || isWaitingForApiResponse) { console.log("SR Start: Blocked"); return; }
        stopSpeech();
        console.log("SR Start: Attempting...");
        isRecordingIntent = true; accumulatedFinalTranscript = ''; isListeningPaused = false; inputField.value = '';
        sounds.start?.play();
        try { recognition.start(); }
        catch (error) { console.error("SR Start: Error -", error); isRecordingIntent = false; handleRecognitionError({ error: error.name || 'start-error', message: error.message }); }
    }

    function stopRecognition(playSound = true) {
        if (!recognition) return;
        console.log("SR Stop: Stopping intent and API.");
        isRecordingIntent = false; isListeningPaused = false;
        if (isApiRecognizing) {
            try { recognition.stop(); if (playSound) sounds.stop?.play(); }
            catch (error) { console.error("SR Stop: Error -", error); isApiRecognizing = false; } // Force state
        } else { console.log("SR Stop: API not running."); }
        updateButtonStates();
    }

    function sendMessage(messageText = null) {
        const text = (messageText !== null ? messageText : inputField.value).trim();
        if (!text || isWaitingForApiResponse) { console.log("Send: Blocked"); return; }

        console.log("Send: Sending:", text);
        isWaitingForApiResponse = true; showTypingIndicator(true); updateButtonStates(); sounds.send?.play();
        addMessage(text, 'user'); inputField.value = ''; accumulatedFinalTranscript = '';
        wasRecordingBeforeTTS = isRecordingIntent; stopRecognition(false);

        const requestBody = {
            contents: buildContext(),
            generationConfig: {},
            safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
            ]
        };

        fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => { throw new Error(errData.error?.message || `HTTP ${response.status}`); })
                        .catch(() => { throw new Error(`HTTP ${response.status}`); });
                } return response.json();
            })
            .then(data => {
                console.log("API Response:", data);
                const botText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                const finishReason = data.candidates?.[0]?.finishReason;
                const blockReason = data.promptFeedback?.blockReason;
                if (botText) { handleApiResponse(botText); }
                else if (finishReason === 'SAFETY' || blockReason) { handleApiResponse(`[Respuesta bloqueada: ${finishReason || blockReason}]`, true); }
                else { handleApiResponse("[Error: Respuesta inesperada]", true); }
            })
            .catch(error => { console.error("API Fetch Error:", error); handleApiResponse(`[Error: ${error.message}]`, true); })
            .finally(() => { isWaitingForApiResponse = false; showTypingIndicator(false); console.log("API Fetch Finished."); });
    }

    function handleApiResponse(botText, isError = false) {
        const botMessageElement = addMessage(botText, 'bot');
        if (!isError) sounds.receive?.play();
        speakText(botText, botMessageElement);
    }

    function speakText(text, messageElement) {
        if (!('speechSynthesis' in window) || !text) { finalizeResponseHandling(); return; }
        stopSpeech();
        currentSpeech = new SpeechSynthesisUtterance(text);
        const selectedOption = voiceSelect.selectedOptions[0];
        const voice = voices.find(v => v.name === selectedOption?.getAttribute('data-name') && v.lang === selectedOption?.getAttribute('data-lang'));

        if (voice) { currentSpeech.voice = voice; currentSpeech.lang = voice.lang; }
        else {
            const fallback = voices.find(v => v.lang.startsWith(TTS_PREFERRED_LANG)) || voices[0];
            if (fallback) { currentSpeech.voice = fallback; currentSpeech.lang = fallback.lang; console.warn("TTS: Using fallback voice", fallback.name); }
            else { console.error("TTS: No voices available!"); finalizeResponseHandling(); return; } // No voice possible
        }
        currentSpeech.rate = parseFloat(rateSelect.value) || 1;
        currentSpeech.pitch = parseFloat(pitchSelect.value) || 1;

        currentSpeech.onstart = () => {
            isSpeaking = true; console.log("TTS: Started."); updateButtonStates();
            if (messageElement) {
                activeSpeakButton = messageElement.querySelector('.speak-button i');
                if (activeSpeakButton) { activeSpeakButton.className = 'fas fa-stop-circle'; activeSpeakButton.parentElement.classList.add('speaking'); }
            }
        };
        currentSpeech.onend = () => { console.log("TTS: Finished."); isSpeaking = false; currentSpeech = null; resetActiveSpeakButton(); finalizeResponseHandling(); };
        currentSpeech.onerror = (e) => { console.error("TTS Error:", e.error); isSpeaking = false; currentSpeech = null; resetActiveSpeakButton(); showSystemMessage(`Error TTS: ${e.error}`, "error"); finalizeResponseHandling(); };
        currentSpeech.onpause = () => { console.log("TTS: Paused."); isSpeaking = false; updateButtonStates(); };
        currentSpeech.onresume = () => { console.log("TTS: Resumed."); isSpeaking = true; updateButtonStates(); };

        speechSynthesis.speak(currentSpeech);
    }

    function finalizeResponseHandling() {
        console.log("Finalizing response. Was recording before:", wasRecordingBeforeTTS);
        updateButtonStates();
        if (wasRecordingBeforeTTS) { console.log("Attempting SR restart after TTS."); startRecognition(); }
        wasRecordingBeforeTTS = false;
    }

    function pauseSpeech() { if (speechSynthesis.speaking && !speechSynthesis.paused) speechSynthesis.pause(); }
    function resumeSpeech() { if (speechSynthesis.paused) speechSynthesis.resume(); }
    function stopSpeech() {
        if (speechSynthesis.speaking || speechSynthesis.paused) {
            speechSynthesis.cancel(); console.log("TTS: Cancelled.");
            // Reset state manually as onend might not fire reliably
            isSpeaking = false; currentSpeech = null; resetActiveSpeakButton(); updateButtonStates();
        }
    }

    // --- UI Update Functions ---
    function addInitialMessage() {
         // Añadir mensaje inicial si el chat está vacío
         if (chatElement.children.length === 0) {
              addMessage("¡Hola! Soy Gemini. Puedes hablarme usando el botón del micrófono o escribir tu mensaje.", 'bot');
         }
    }

    function addMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
        messageDiv.textContent = text; // Usar textContent es más seguro
        if (sender === 'bot') addSpeakButton(messageDiv);
        chatElement.appendChild(messageDiv);
        scrollToBottom();
        if (sender !== 'system') updateConversationHistory(text, sender); // No guardar mensajes de sistema en historial
        return messageDiv;
    }

     function addSpeakButton(messageElement) {
        const button = document.createElement('button');
        button.className = 'speak-button'; button.title = "Leer mensaje";
        button.innerHTML = '<i class="fas fa-volume-up"></i>';
        button.onclick = () => speakMessage(messageElement);
        messageElement.appendChild(button);
    }

    function speakMessage(messageElement) {
         const textToSpeak = Array.from(messageElement.childNodes)
            .filter(node => node.nodeType === Node.TEXT_NODE)
            .map(node => node.textContent.trim()).join(' ');
        if (textToSpeak) {
            console.log("Speaking message:", textToSpeak);
            const isCurrentlySpeakingThis = isSpeaking && activeSpeakButton && activeSpeakButton.closest('.message') === messageElement;
            if (isCurrentlySpeakingThis) { stopSpeech(); } // Si se hace clic en el botón del mensaje que se está leyendo, detenerlo
            else { if (isSpeaking) stopSpeech(); setTimeout(() => speakText(textToSpeak, messageElement), 50); } // Detener otro y empezar este
        }
    }

     function resetActiveSpeakButton() {
        if (activeSpeakButton) {
            activeSpeakButton.className = 'fas fa-volume-up'; // Reset icon
            if (activeSpeakButton.parentElement) activeSpeakButton.parentElement.classList.remove('speaking');
            activeSpeakButton = null;
        }
    }

    function showSystemMessage(text, type = "info") {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'system-message';
        if (type === 'error') messageDiv.style.color = '#dc3545'; // Estilo error básico
        messageDiv.textContent = text;
        chatElement.appendChild(messageDiv);
        scrollToBottom();
    }

    function showTypingIndicator(show) { typingIndicator.classList.toggle('hidden', !show); if (show) scrollToBottom(); }
    function scrollToBottom() { if (autoScrollEnabled) chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' }); }
    function ensureInputFieldVisible() { inputField.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

    function updateButtonStates() {
        startBtn.disabled = isRecordingIntent || isSpeaking || isWaitingForApiResponse;
        explicitStopBtn.disabled = !isRecordingIntent;
        pauseBtn.disabled = !isSpeaking || speechSynthesis.paused;
        resumeBtn.disabled = !speechSynthesis.paused;
        stopBtn.disabled = !isSpeaking && !speechSynthesis.paused;
        sendBtn.disabled = isWaitingForApiResponse;
        inputField.disabled = isWaitingForApiResponse;
        toggleConfigBtn.disabled = false;
        if (isListeningPaused) { startBtn.innerHTML = '<i class="fas fa-hourglass-half"></i> Esperando...'; startBtn.disabled = true; explicitStopBtn.disabled = false; }
        else if (!startBtn.disabled) { startBtn.innerHTML = '<i class="fas fa-microphone"></i> Hablar'; }
        // console.log("Buttons Updated - Intent:", isRecordingIntent, "API:", isApiRecognizing, "Speak:", isSpeaking, "Wait:", isWaitingForApiResponse, "PausedTTS:", speechSynthesis.paused, "PausedListen:", isListeningPaused); // Log más corto
    }

    // --- Configuration Menu ---
    function toggleConfigMenu() { configMenu.classList.toggle('hidden'); }

    // --- Theme Management ---
    function applyTheme(theme) {
        document.body.setAttribute('data-theme', theme);
        currentTheme = theme;
    }
    function toggleTheme() {
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        applyTheme(newTheme);
        saveSetting(STORAGE_KEYS.THEME, newTheme); // Guardar tema
    }

    // --- Context / Conversation History ---
    function buildContext() { return conversationHistory.slice(-MAX_CONTEXT_MESSAGES * 2); }
    function updateConversationHistory(text, role) {
         const apiRole = (role === 'user') ? 'user' : 'model';
         conversationHistory.push({ role: apiRole, parts: [{ text: text }] });
         if (conversationHistory.length > MAX_CONTEXT_MESSAGES * 2) conversationHistory.splice(0, 2);
         updateContextIndicator();
    }
    function clearContext() {
        conversationHistory = []; chatElement.innerHTML = ''; addInitialMessage();
        showSystemMessage("Contexto borrado.", "info"); updateContextIndicator(); console.log("History cleared.");
    }
     function updateContextIndicator() {
        const pairs = Math.floor(conversationHistory.length / 2);
        contextIndicator.textContent = `Contexto: ${pairs}`; // Texto más corto
        contextIndicator.className = 'context-indicator '; // Reset classes
        if (pairs === 0) contextIndicator.classList.add('empty');
        else if (pairs < MAX_CONTEXT_MESSAGES * 0.6) contextIndicator.classList.add('medium');
        else contextIndicator.classList.add('full');
        contextIndicator.title = `Contexto (${pairs}/${MAX_CONTEXT_MESSAGES} pares)`;
    }

    // --- Event Listeners ---
    function addEventListeners() {
        inputField.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } });
        sendBtn.addEventListener('click', () => sendMessage());
        startBtn.addEventListener('click', startRecognition);
        explicitStopBtn.addEventListener('click', () => stopRecognition(true));
        pauseBtn.addEventListener('click', pauseSpeech);
        resumeBtn.addEventListener('click', resumeSpeech);
        stopBtn.addEventListener('click', stopSpeech);
        toggleConfigBtn.addEventListener('click', toggleConfigMenu);
        closeConfigBtn.addEventListener('click', toggleConfigMenu);

        // Guardar configuraciones al cambiar
        voiceSelect.addEventListener('change', () => {
            const selectedOption = voiceSelect.selectedOptions[0];
            if (selectedOption) {
                saveSetting(STORAGE_KEYS.VOICE_NAME, selectedOption.getAttribute('data-name'));
                saveSetting(STORAGE_KEYS.VOICE_LANG, selectedOption.getAttribute('data-lang'));
                console.log("Saved voice:", selectedOption.getAttribute('data-name'));
            }
            stopSpeech(); // Detener si se cambia la voz mientras habla
        });
        rateSelect.addEventListener('input', () => {
            const value = parseFloat(rateSelect.value).toFixed(1);
            rateValue.textContent = value;
            saveSetting(STORAGE_KEYS.RATE, value);
        });
        pitchSelect.addEventListener('input', () => {
            const value = parseFloat(pitchSelect.value).toFixed(1);
            pitchValue.textContent = value;
            saveSetting(STORAGE_KEYS.PITCH, value);
        });
        clearContextBtn.addEventListener('click', clearContext);
        themeToggle.addEventListener('change', toggleTheme);

        // Control de auto-scroll
        let scrollTimeout;
        chatContainer.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            const isNearBottom = chatContainer.scrollHeight - chatContainer.clientHeight <= chatContainer.scrollTop + 50;
            if (!isNearBottom) autoScrollEnabled = false;
            scrollTimeout = setTimeout(() => { if (isNearBottom) autoScrollEnabled = true; }, 500);
        });
    }

    </script>
</body>
</html>
